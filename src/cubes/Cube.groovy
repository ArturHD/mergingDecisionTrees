/*
 Copyright (c) 2013 by Artur Andrzejak <arturuni@gmail.com>, Felix Langner, Silvestre Zabala

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.


 */

package cubes

import weka.core.Instance
import weka.core.Instances

/**
 * Created by IntelliJ IDEA.
 * User: Artur Andrzejak
 * Date: 16.01.12
 * Time: 21:17
 * Container for a d-dimensional iso-oriented box
 */
@Typed
class Cube implements Cloneable {

    // total number of dimensions
    int nDims

    // the upper and lower bounds - or as matrix?
    // 1. coordinate: index of the dimension
    // 2. coordinate: lower (0) or upper (1) bound
    // bounds[i] == null indicates no restriction on attribute (dimension not used in path)
    double[][] bounds

    // number of instances which fall inside of this cube (June 2012)
    // todo: find out the right code parts to update this field, currently it is in MergedTreeClassifier.resolveConflicts()
    int numInstances

    private volatile cashedHashCode
    private volatile isHashCodeValid = false


    // initialises bounds in the 1st index
    Cube(int numberDimensions) {
        nDims = numberDimensions
        bounds = new double[nDims][]
    }

    // equal generated by @EqualsAndHashCode does seem to have a problem with double[][] bounds
    @Override
    boolean equals(Object other) {
        if (other == null) return false
        if (this.is(other)) return true
        if (!(other instanceof Cube)) return false
        Cube o = (Cube) other
        // equal objects need to have equal hashCodes
        if (this.hashCode() != o.hashCode()) return false
        if (nDims != o.nDims) return false
        return Arrays.deepEquals(this.bounds, o.bounds)
//        for (int i=0; i <nDims; i++)
//            if ((getLower(i) != o.getLower(i)) || (getUpper(i) != o.getUpper(i))) return false
//        return true
    }

    int hashCode() {
        if (isHashCodeValid)
            return cashedHashCode

        int result
        result = nDims
        result = 31 * result + Arrays.deepHashCode(bounds)

        cashedHashCode = result
        isHashCodeValid = true
        return result
    }


    Cube clone() {
        Cube result = (Cube) super.clone()  // AA: this already clones the ClassData - but why?
        result.nDims = nDims
        result.isHashCodeValid = false
        result.numInstances = numInstances

        // see also a deep clone of an object - http://www.jguru.com/faq/view.jsp?EID=20435
        result.bounds = new double[nDims][]
        for (int i = 0; i < nDims; i++) {
            if (bounds[i] != null) {
                result.bounds[i] = new double[2]
                result.bounds[i][0] = bounds[i][0]
                result.bounds[i][1] = bounds[i][1]
            }
        }
        return result
    }

    boolean isBounded(int dimensionIdx) {
        // convention: non allocated bounds -> unbounded
        if (bounds[dimensionIdx] == null) return false
        boolean bounded = bounds[dimensionIdx][0] != Double.NEGATIVE_INFINITY || bounds[dimensionIdx][1] != Double.POSITIVE_INFINITY
        if (!bounded) bounds[dimensionIdx] = null   // "deallocate" array entry for this dimension
        return bounded
    }

    boolean missingAtLeastOneBound() {

        for (dim in 0..nDims) {
            if (!bounds[dim] || bounds[dim][0] == Double.NEGATIVE_INFINITY || bounds[dim][1] == Double.POSITIVE_INFINITY) {
                return true
            }
        }

        return false
    }

    double getLower(int dimensionIdx) {
        if (bounds[dimensionIdx] == null)
            return Double.NEGATIVE_INFINITY
        return bounds[dimensionIdx][0]
    }

    double getUpper(int dimensionIdx) {
        if (bounds[dimensionIdx] == null)
            return Double.POSITIVE_INFINITY
        return bounds[dimensionIdx][1]
    }

    // returns true if value is in the projection (i.e. interval) of the specified dimension
    boolean isInProjection(int dimensionIdx, double value) {
        if (bounds[dimensionIdx] == null)   // we have no bounds on this dim, all ok
            return true
        if (getLower(dimensionIdx) > value || getUpper(dimensionIdx) < value)
            return false
        return true
    }

    /**
     * Determines whether an instance is covered by this cube.
     *
     * @param instance - the Instance to check.
     * @return true if the given instance is covered by this cube, false otherwise.
     */
    boolean isInsideCube(Instance instance) {
        // check coverage for all attributes
        for (int dimIndex = 0; dimIndex < nDims; dimIndex++) {
            if (bounds[dimIndex] == null)   // we have no bounds on this dim, all ok
                continue;

             double attribValue = instance.value(dimIndex)
            // some attribute values are NaNs, skip these
            if (Double.isNaN(attribValue))
                break
            if ( ! isInProjection(dimIndex, attribValue))
                return false
        }
        return true
    }

    /**
     * Returns number of instances contained within this cube for an instances container
     * @param instances
     * @return number of instances contained within this cube for an instances container
     */
    int numInstancesInsideCube(Instances instances) {
        int numInstances = instances.numInstances()
        int result = 0
        for (i in 0..<numInstances) {
            def instance = instances.instance(i)
            if (isInsideCube(instance))
                result++
        }
        return result
    }

    /**
     * @return the center of the cube as a d-dimensional point.
     */
    double[] getCenter() {

        double[] result = new double[nDims]

        for (int i = 0; i < nDims; i++) {

            double lower = getLower(i)
            result[i] = (((double)(getUpper(i) - lower)) / 2.0) + lower
        }

        return result
    }

    // Checks whether for dim dimensionIdx there is already allocated memory if not not, does it
    private initDimensionMemory(int dimensionIdx) {
        if (bounds[dimensionIdx] == null) {
            bounds[dimensionIdx] = new double[2]
            bounds[dimensionIdx][0] = Double.NEGATIVE_INFINITY
            bounds[dimensionIdx][1] = Double.POSITIVE_INFINITY
        }
        isHashCodeValid = false
    }

    void setBounds(int dimensionIdx, double lower, double upper) {
        assert lower <= upper
        initDimensionMemory(dimensionIdx)
        bounds[dimensionIdx][0] = lower
        bounds[dimensionIdx][1] = upper
    }

    def setLower(int dimensionIdx, double newLower) {
        assert newLower <= getUpper(dimensionIdx)
        initDimensionMemory(dimensionIdx)
        bounds[dimensionIdx][0] = newLower
    }

    def setUpper(int dimensionIdx, double newUpper) {
        assert newUpper >= getLower(dimensionIdx)
        initDimensionMemory(dimensionIdx)
        bounds[dimensionIdx][1] = newUpper
    }

    boolean intersects(Cube o) {
        for (int i in 0..<nDims)
            if (this.isBounded(i) && o.isBounded(i))
                if ((this.getLower(i) >= o.getUpper(i)) || (this.getUpper(i) <= o.getLower(i)))
                    return false
        return true
    }


    /** Returns a clone of this cube with the bounds set to the intersection or null if the cubes did not intersect */
    Cube intersectBounds(Cube c) {
        if (this.intersects(c)) {
            def result = this.clone()
            for (int i in 0..<nDims) {
                if (isBounded(i) || c.isBounded(i)) {
                    def lower = Math.max(getLower(i), c.getLower(i))
                    def upper = Math.min(getUpper(i), c.getUpper(i))
                    result.setBounds(i, lower, upper)
                }
            }
            return result
        }
        else
            return null
    }

    /** Returns true if every lower bound is strictly smaller than the higher bound.
     *  This implies that hyperplanes do not have valid bounds */
    protected boolean hasValidBounds() {
        for (int i in 0..<nDims)
            if (isBounded(i))
                if (getLower(i) >= getUpper(i))
                    return false
        return true
    }

    // Checks whether this and other are equal except for one specified dimension dim
    boolean equalBoundsExceptOneDim(ClassCube otherCube, int dim) {
        if (nDims != otherCube.nDims) return false
        for (int i in 0..<nDims)
            if (i != dim)
                if ((getLower(i) != otherCube.getLower(i)) || (getUpper(i) != otherCube.getUpper(i))) return false
        return true

    }

    // Computes the smallest cube which encloses this one and the other cube
    Cube getEnclosing(Cube otherCube) {
        // if (otherCube == null)
        //     return null
        assert nDims == otherCube.nDims, "Number of dimensions do not agree"
        Cube result = new Cube(nDims)
        for (int dim = 0; dim < nDims; dim++) {
            if (this.isBounded(dim) || otherCube.isBounded(dim)) {
                double lower = Math.min (this.getLower(dim), otherCube.getLower(dim))
                double upper = Math.max (this.getUpper(dim), otherCube.getUpper(dim))
                result.setBounds(dim, lower, upper)
            }
        }
        return result
    }


    @Override
    String toString() {
        int usedDims
        def bsb = new StringBuilder(20)
        if (bounds == null) {
            bsb << "(empty)"
        } else {
            for (int dimIndex in 0..<nDims) {
                def dimBounds = bounds[dimIndex]
                if (dimBounds != null) {
                    usedDims++
                    bsb << "D$dimIndex:$dimBounds, "
                }
            }
        }
        def numInstString = numInstances > 0 ? ", numInst=$numInstances" : ""
        return "nDims=$nDims/$usedDims $numInstString, bounds=$bsb"
    }
}
